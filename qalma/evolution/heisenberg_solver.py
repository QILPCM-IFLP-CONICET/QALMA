"""
Solve a truncated hierarchy of Heisenberg equations for a set of observables.
"""

from typing import Any, Callable, Dict, Iterable, Optional, cast

import numpy as np
from numpy.typing import NDArray

from qalma.operators import Operator
from qalma.operators.states import DensityOperatorProtocol
from qalma.scalarprod.basis import HierarchicalOperatorBasis, OperatorBasis
from qalma.scalarprod.build import fetch_covar_scalar_product


def heisenberg_solve(
    H: Operator,
    rho0: DensityOperatorProtocol,
    tlist: NDArray,
    e_ops: list[Operator] | dict[Any, Operator],
    *,
    deep: int = 2,
    args: Optional[Dict[str, Any]] = None,
    options: Optional[Dict[str, Any]] = None,
    sp: Optional[Callable] = None,
) -> NDArray | Dict[Any, Operator]:
    """
    Compute the expectation values of the operators listed in e_ops
    as a function of `t` in `tlist`, following a Heisenberg evolution
    generated by the Hamiltonian `H` relative to the state `rho0`.

    """
    if sp is None:
        sp = fetch_covar_scalar_product(rho0)

    seeds: Iterable[Operator] = e_ops.values() if isinstance(e_ops, dict) else e_ops
    # Build a basis as a union of the hierarchical basis generated by each
    # operator.
    basis: OperatorBasis = cast(
        OperatorBasis,
        sum(HierarchicalOperatorBasis(seed, -H, deep, sp) for seed in seeds),
    )
    basis_expectation_values: NDArray = np.array(rho0.expect(basis.operator_basis))
    fields_0: NDArray = np.array([basis.coefficient_expansion(op) for op in seeds]).T
    result: list = []
    for t in tlist:
        phis = basis_expectation_values @ basis.evolve(t, fields_0)[0]
        result.append(phis)

    result_np = np.array(result).T

    if isinstance(e_ops, dict):
        return {key: val for key, val in zip(e_ops.keys(), result_np)}
    return result_np
