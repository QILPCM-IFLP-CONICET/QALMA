"""
Solve a truncated hierarchy of Heisenberg equations for a set of observables.
"""

from typing import Any, Callable, Dict, Iterable, Optional, cast

import numpy as np
from numpy.typing import NDArray

from qalma.operators import Operator
from qalma.operators.states import DensityOperatorProtocol
from qalma.scalarprod.basis import HierarchicalOperatorBasis, OperatorBasis
from qalma.scalarprod.build import fetch_covar_scalar_product

from .simulation import Simulation


def heisenberg_solve(
    H: Operator,
    rho0: DensityOperatorProtocol,
    tlist: NDArray,
    e_ops: list[Operator] | dict[Any, Operator],
    *,
    deep: int = 2,
    args: Optional[Dict[str, Any]] = None,
    options: Optional[Dict[str, Any]] = None,
    sp: Optional[Callable] = None,
) -> Simulation:
    """
    Compute the expectation values of the operators listed in e_ops
    as a function of `t` in `tlist`, following a Heisenberg evolution
    generated by the Hamiltonian `H` relative to the state `rho0`.

    """
    if options is None:
        options = {}

    if sp is None:
        sp = fetch_covar_scalar_product(rho0)

    if not isinstance(e_ops, dict):
        e_ops = {key: e_op for key, e_op in enumerate(e_ops)}

    seeds: Iterable[Operator] = e_ops.values()
    # Build a basis as a union of the hierarchical basis generated by each
    # operator.
    basis: OperatorBasis = cast(
        OperatorBasis,
        sum(HierarchicalOperatorBasis(seed, -H, deep, sp) for seed in seeds),
    )
    basis_expectation_values: NDArray = np.array(rho0.expect(basis.operator_basis))
    fields_0: NDArray = np.array([basis.coefficient_expansion(op) for op in seeds]).T
    result: list = []
    for t in tlist:
        phis = basis_expectation_values @ basis.evolve(t, fields_0)[0]
        result.append(phis)

    return Simulation(
        parameters=options.copy(),
        stats={},
        time_span=[t for t in tlist],
        expect_ops={key: val for key, val in zip(e_ops.keys(), np.array(result).T)},
        states=[],
    )
