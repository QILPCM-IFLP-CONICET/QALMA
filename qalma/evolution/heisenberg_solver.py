"""
Solve a truncated hierarchy of Heisenberg equations for a set of observables.
"""

from typing import Any, Callable, Optional

import numpy as np
from numpy.typing import ArrayLike

from qalma.operators import Operator
from qalma.scalarprod.basis import HierarchicalOperatorBasis
from qalma.scalarprod.build import fetch_covar_scalar_product


def heisenberg_solve(
    H: Operator,
    rho0: Operator,
    tlist: ArrayLike,
    e_ops: list[Operator] | dict[Any, Operator],
    *,
    deep: int = 2,
    args: dict[str, Any] = None,
    options: dict[str, Any] = None,
    sp: Optional[Callable] = None,
) -> list[Operator] | dict[Any, Operator]:
    """
    Compute the expectation values of the operators listed in e_ops
    as a function of `t` in `tlist`, following a Heisenberg evolution
    generated by the Hamiltonian `H` relative to the state `rho0`.

    """
    if sp is None:
        sp = fetch_covar_scalar_product(rho0)

    seeds = e_ops.values() if isinstance(e_ops, dict) else e_ops
    # Build a basis as a union of the hierarchical basis generated by each
    # operator.
    basis = sum(HierarchicalOperatorBasis(seed, -H, deep, sp) for seed in seeds)
    basis_expectation_values = np.array(rho0.expect(basis.operator_basis))
    fields_0 = np.array([basis.coefficient_expansion(op) for op in seeds]).T
    result = []
    for t in tlist:
        phis = basis_expectation_values @ basis.evolve(t, fields_0)[0]
        result.append(phis)

    result_np = np.array(result).T

    if isinstance(e_ops, dict):
        return {key: val for key, val in zip(e_ops.keys(), result_np)}
    return result_np
